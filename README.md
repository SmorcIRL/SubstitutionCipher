# SubstitutionCipher
Репозиторий содержит реализацию [шифра простой замены](https://ru.wikipedia.org/wiki/Шифр_простой_замены) и его криптоанализ. Для криптоанализа был использован генетический алгоритм([фитнесс-функция](https://github.com/SmorcIRL/TextFitnessCalculator)). Алгоритм справляется с довольно объемными текстами (~5 мб), но логично будет перед взломом больших текстов сначала попробовать взломать небольшие отрывки из них, что, в случае успеха, скорее всего будет означать нахождение ключа для всего текста.

### Выбор параметров генетического алгоритма

Обычно в генетическом алгоритме (в т.ч. статьях, приведенных ниже) советуют выбирать небольшую вероятность мутации и полагаются в основном на кроссовер, что дает стабильный рост приспособленности поколений и не дает мутациям "загубить" прогресс. Однако в случае с шифром простой замены, по крайней мере в моей реализации (довольно сложно придумать нормальный оператор кроссовера), при таком подходе кроссовер не обеспечивает необходимого роста, поколения часто застревают на "локальном максимуме" фитнесс-функции и не могут с него сдвинуться.

По моим наблюдениям, выгоднее всего выбирать, казалось бы, неприемлемо-большой шанс мутации для индивида, ограничивая при этом эту мутацию до минимума (в поколении мутирует почти каждый ключ-индивид, но всего на пару ген). Ключ-индивид очень чувствителен к мутации, одна удачная перестановка генов может значительно улучшить приспособленность, но также может и значительно ухудшить (это следует как минимум из сильного разброса в распределении частот букв). В среднем это происходит с одинаковой вероятностью для небольшого количества мутирующих ген, поэтому в мутации я использую "удвоенное" по размеру, после кроссовера, поколение, выбирая после сортировки лучшую половину, которая и переходит в следующее поколение. 

В итоге алгоритм лучше всего работает с шансом мутации индивида в 80% и количеством ген для мутации [1,2]. Выбор размера поколения думаю можно как-то теоретически связать с длиной алфавита; для моих тестов пару сотен - оптимальное значение. Порог фитнесс-функции зависит в основном от языка и самого текста, можно запускать несколько раз, постепенно понижая значение. Вообще, в случае если взлом текста застревает на близком к "нормальному" значении фитнесс-функции, следует позапускать алгоритм несколько раз, возможно получилась серия "неудачных" первых поколений (генерируются абсолютно случайно).

### Полезные ссылки:
- [Основная статья](https://planetcalc.com/8047/)
- [Фитнесс-функция](https://planetcalc.com/8045/) и [реализация](https://github.com/SmorcIRL/TextFitnessCalculator)
- [Генетический алгоритм](https://people.cs.uct.ac.za/~jkenwood/JasonBrownbridge.pdf)
