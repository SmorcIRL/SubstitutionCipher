# SubstitutionCipher
В репозитории содержится реализация [шифра простой замены](https://ru.wikipedia.org/wiki/Шифр_простой_замены) и, что интереснее, его криптоанализ. Для криптоанализа был использован генетический алгоритм с [фитнесс-функцией](https://github.com/SmorcIRL/TextFitnessCalculator). Основная сложность в алгоритме - придумать нормальный оператор для скрещивания; в данной реализации два ключа-родителя дают двух потомков, гены которых выбираются из родителей с вероятностью, зависящей от соотношения их фитнесс-функций. Алгоритм справляется с довольно объемными текстами (~5 мб), но логично что если использован данный шифр, скорее всего все части текста зашифрованы одним и тем же ключом, а значит взлом небольшого абзаца обеспечит расшифровку всего текста, которая выполняется мгновенно с полученным ключом.

### Выбор параметров генетического алгоритма

Обычно в генетическом алгоритме (в т.ч. статьях, приведенных ниже) советуют выбирать небольшой шанс мутации индивидов и пологаются в основном на кроссовер, что дает стабильный рост приспособленности поколений. Однако в данном случае, по крайней мере в моей реализации, кроссовер не обеспечивает необходимого роста приспособленности, поколения часто застревают на "локальном максимуме" и не могут с него сдвинуться.

Поэтому, по моим наблюдениям, выгоднее всего выбирать неприемлимо-большой шанс мутации индивида, ограничивая при этом эту мутацию до минимума (в поколении мутирует почти каждый ключ-индивид, но всего на пару ген). В то же время ключ-индивид очень чувствителен к мутации, одна удачная перестановка генов может значительно улучшить приспособленность, но так же может и значительно ухудщить (это следует как минимум из сильного разброса в распределении частот букв). В среднем это происходит с одинаковой вероятностью для небольшого количества мутирующих ген, поэтому в мутации я использую "удвоенное" по размеру, после кроссовера, поколение, выбирая после сортировки лучшую половину, которая и переходит в следущее поколение. 

В итоге алгоритм лучше всего работает с шансом мутации индивида в 80% и количеством ген для мутации [1,2]. Выбор размера поколения думаю можно как-то теоретически связать с длиной алфавита; для моих тестов пару сотен - оптимальное значение. Порог фитнесс-функции зависит в основном от языка и самого текста, можно запускать несколько раз, постепенно понижая планку. И вообще в случае если взлом текста застревает на близком к "нормальному" значении фитнесс-функции, следует позапускать алгоритм несколько раз, так как первое поколение создается совершенно случайно. 

### Полезные ссылки:
- [Основная статья](https://planetcalc.com/8047/)
- [Фитнесс-функция](https://planetcalc.com/8045/)
- [Генетический алгоритм](https://people.cs.uct.ac.za/~jkenwood/JasonBrownbridge.pdf)
